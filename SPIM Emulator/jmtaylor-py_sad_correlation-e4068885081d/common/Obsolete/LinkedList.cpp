#include "LinkedList.h"void LinkedListElement::InsertAfter(LinkedListElement *theOneBefore){	ASSERT(!InList());	next = theOneBefore->next;	prev = theOneBefore;	next->prev = this;	prev->next = this;}void LinkedListElement::InsertBefore(LinkedListElement *theOneAfter){	ASSERT(!InList());	next = theOneAfter;	prev = theOneAfter->prev;	next->prev = this;	prev->next = this;}void LinkedListElement::RemoveFromList(void){	ASSERT(InList());	next->prev = prev;	prev->next = next;	next = this;	prev = this;}long LinkedListElement::GetListLength(void) const{	long	length = 0;	ASSERT(self == NULL);		// Should only be called for list head	for (LinkedListElement *element = next; element != this; element = element->next)		length++;	return(length);}LinkedListElement *LinkedListElement::IterateToFindListHead(void){	// Iterate through the list from this item until we find the list head	LinkedListElement	*element = this;	while (element->Self() != NULL)	{		ASSERT(element != NULL);		ASSERT(element->NextNode() != NULL);		element = element->NextNode();	}	return element;}void LinkedListElement::PopulateArrayWithListElementSelves(void **array) const{	long	elementNum = 0;	ASSERT(self == NULL);		// Should only be called for list head	for (LinkedListElement *element = next; element != this; element = element->next, elementNum++)		array[elementNum] = element->self;}void LinkedListElement::MakeListEmpty(void){	LinkedListElement	*element;	while ((element = next) != this)		element->RemoveFromList();}void LinkedListElement::MakeNewHead(LinkedListElement *oldHead){	ASSERT(self == NULL);	ASSERT(oldHead != NULL);	ASSERT(oldHead->self == NULL);		if (oldHead->next == oldHead)	{		// It was an empty list		next = this;		prev = this;	}	else	{		next = oldHead->next;		prev = oldHead->prev;		prev->next = this;		next->prev = this;		}}