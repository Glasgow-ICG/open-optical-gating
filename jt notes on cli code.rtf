{\rtf1\ansi\ansicpg1252\cocoartf1404\cocoasubrtf470
{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fnil\fcharset0 Menlo-Bold;\f2\fnil\fcharset0 Menlo-Regular;
}
{\colortbl;\red255\green255\blue255;\red170\green13\blue145;\red28\green0\blue207;\red196\green26\blue22;
}
\paperw11900\paperh16840\margl1440\margr1440\vieww21540\viewh20240\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\b\fs24 \cf0 I [jonny] have made changes to the source code on a new branch (todos, improved comments, and a few changes to function/variable names etc)
\b0 . Where possible I have edited as I go, but am hoping for your input on resolving the queries in the todos. The more important conceptual queries are listed below.
\b  I have also included a preliminary sketch of the architecture I have in mind
\b0 , although this is currently limited by my understanding of how the flask stuff works, particularly around multithreading, since that will have a big influence on what a correct and best way to handle all this in python will be. My biggest hangup is that I cannot see any connection between app.py and camera_pi.py (and in particular the frames() iterator). I therefore cannot see how the Flask app stuff is meant to work when running live on a RPi with the PiCam.\
\

\b \
\
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97 Queries to Chas about the different modules \'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\b0 \cf0 \ul \ulc0 \
cpi.py\
\ulnone OpticalGater class that extends picamera.array.PiYUVAnalysis. It appears to maintain history, e.g. frame_history, period_history.\

\b For chas: 
\b0 my opinion is frame_history is really crying out for a class container, or at least an array with named columns (or a list-of-dictionaries, though I\'92m less keen on that). At present it requires the developer to keep track of the meaning of each column, and the format not easily extensible.\

\b For chas: 
\b0 load_data() - \'93Place holder function for loading data in emulator\'94. What is the intention of this, and is there a clear idea of what an emulator would look like?\
	
\b For me: 
\b0 this is a general question for Chas: how does he intend the emulator to work? I don\'92t think I\'92ve fully followed his emulator stuff in \'93app\'94. Might need to talk through that one together\'85\ul \

\b \ulnone For chas: IMPORTANT, BUG: 
\b0 as per my comment in this module, I don\'92t think barrier frames are implemented properly.\

\b For chas: IMPORTANT, BUG: 
\b0 I think there is a bug associated with (lack of) numExtraRefFrames in initialise_internal_parameters(), as per my comment there.\

\b For chas: IMPORTANT, approaching a BUG
\b0 : there is the general issue that the code is not doing a great job of precise timing. It determines a delay time before sending the trigger, but then executes a bunch more code. Oh, and that delay time is then treated relative to \'93current_time\'94, which is set 
\i after
\i0  doing the phase-matching. This is going to reduce accuracy and precision, and also makes me even more uncomfortable in terms of future-proofing. I think it would be much better to pass around absolute times, not deltas.\

\b For chas
\b0 : more generally, I wish we were working with frame 
\i objects
\i0  that have accompanying metadata\'a0(such as timestamp!). That would help solve the above issue about timings in a tidy manner, and also make it a lot easier to generalise to other timebases (such as camera timebase, rather than computer). Oh, and it would also help deal with gaps in the timebase (missing frames), which I think would be a useful thing to cope with, even if right now there might not be any concrete scenario in which frames would be dropped. I fear I may not win that argument about frame objects, since it would be quite a big structural change. But, do you have any alternative ideas about how best to cope with the fact that we may well want to work in terms of timebases other than the computer\'92s own timebase?\
Remark 
\b for chas:
\b0  currently when we schedule a trigger everything hangs, waiting for the appropriate time to arrive. This stalls camera and sync analysis. Don\'92t you think we should really figure out a way of doing this asynchronously, without blocking (or come to a definite conclusion that blocking is the only reliable enough way to do it on the Pi).\

\b For me: where do the stages come in? 
\b0 cli.py sets up the usb/serial link, but where is it used, by whom, and when? Should be clearer after a refactor. Either we need to conditionally interact with the stages, or we do it on a more distributed basis, in response to events. That\'92s more how I do it in my code, and I like that approach.\
\ul \
determine_reference_period.py\

\b \ulnone For me and chas: 
\b0 here and elsewhere, I\'92m happy to help refactor into a class myself. This module definitely needs some sort of refactoring (see \'93WTF\'94/\'93Ugh\'94 comments).\

\b For chas
\b0 : padding flag seems to be used fairly inconsistently (would affect the if test in establish_indices), and when False they 
\i still
\i0  seem to include extra ref frames, just fewer of them. Weird\'85. In fact, do you ever 
\i not 
\i0 use it, or should we just remove the parameter?\

\b For chas
\b0 : 
\b IMPORTANT:
\b0  there is a structural issue here where the period-determination code processes one big block of frame buffers all together, once. That is not a good solution when running live - it will be much better to make a new attempt to determine a period after each individual new frame is received, rather than doing a massive chunk of processing in the loop in establish_indices. I really think this needs a refactor. Otherwise, apart from anything else, we will end up acquiring significantly more frames than we need to before we can establish a period. There are also scenarios where this approach will fail, where it could succeed if it was allowed just to keep trying indefinitely, processing a rolling buffer of recent frames. (Minor related observation: once that is changed, and the loop is removed from this function, the \'93didn\'92t find a period\'94 error will not be \'93critical\'94 when running live)\
\
\ul prospective_optical_gating.py\
\ulnone [No comments beyond the inline ones in the source code]\ul \
\ulnone \
\ul emulate.py\ulnone \
I haven\'92t really read through this in detail yet, but I do remember that I didn\'92t find it particularly helpful as an example to follow when I was trying to do my own offline analysis using this codebase. I need to go back and remind myself what the difficulties were that I encountered\'85
\b \

\b0 \
\ul stage_control_functions.py\ulnone \
Looks pretty well commented and structured, but I would implement this as a class, so that other (sub-)classes could be substituted to control other stage types, etc. I will give this some more thought. 
\b For me
\b0 : how is this used? Which object is the most sensible one to be in charge of all this?\
\
\ul app\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0
\cf0 \ulnone For my benefit: base_camera.py runs a background thread which posts events whenever a frame is available. frames() uses \'93yield\'94 to pass frame buffers to an iterator. \
app.gen() is a \'93video streaming generator function\'94 which in turn \'93yield\'94s frames (in what looks like a MIME-like format) to the caller. I am not clear how video_feed behaves, though.\
Basic questions 
\b for chas
\b0 :\
- What is the overall function of app.py? Do I understand correctly that these decorated functions are called in response to messages from the client webpage? In response to those messages, they appear to both perform internal state-affecting actions (i.e. run the synchronization algorithms, in some cases), 
\i and also
\i0  then return the actual HTTP source(*) that should now be displayed in the webpage. Am I understanding that correctly? What is the deal with the \'93session\'94 object? Could really do with a comment at the top of the module to explain what\'92s going on with all of this.        (*) Oh, or sometimes raw video images apparently, in video_feed()\'85\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0
\cf0 - 
\b IMPORTANT: 
\b0 When app.run() refers to \'93live\'94, is that what actually gets run for live sync with a microscope, fish and everything? Because, for instance, it calls through to 
\f1\b\fs22 \CocoaLigature0 emulate
\f2\b0 _get_period\'85
\f0\fs24 \CocoaLigature1 !? I don\'92t know if this is because, as you said, the app code needs updating, but I can\'92t see how it is meaningfully interacting with cli in the case of 
\b live
\b0  frames, and I can\'92t quite picture how that even 
\i should
\i0  work. It seems like the gen() function should be being used somehow, but that\'92s not being used except in video_feed().\
- base_camera.py needs a similar comment at the top of the module explaining what\'92s going on - and in particular what the relationship is between a \'93client\'94 and a \'93thread\'94, explanation of the role of \'93ident\'94 (which is a unique identifier associated with each thread), etc. Are these concurrent threads or [I suspect] sequential threads? Really needs an explanation of the thread architecture here, and the role of \'93yield\'94 in terms how of the threads interact.\
- 
\b IMPORTANT:
\b0  the same questions apply to the Flask app. As per my comment in app.py, I am starting to suspect that this could be running concurrent threads. That needs careful thought and documenting, because it gets very complicated. \
- More generally, 
\i as far as I can see
\i0 , there doesn\'92t seem to be to be a critical need to be using [sequential] threads here at all (though it doesn\'92t do any harm). Out of interest, is this code just adapted from some online example? I suspect it makes a lot more sense in the case where there is 
\i more than one
\i0  client involved (but I don\'92t think that\'92s really an issue for us in reality).\
\
\
\

\b Out of interest: 
\b0 I find the code formatting [newline after \'93(\'93, and \'93)\'94 on a line of its own, sometimes doing this in rather superfluous contexts] really weird. Is this an established coding style, or just what Alex does!? It\'92s certainly one way to keep to line-width limits, but not the one I would choose - and line limits are violated elsewhere! Extreme example:\
\pard\tx529\pardeftab529\pardirnatural\partightenfactor0

\f2\fs22 \cf0 \CocoaLigature0                     self.trigger_fluorescence_image_capture(\
                                                            current_time + timeToWaitInSecs\
                                                            )\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs24 \cf0 \CocoaLigature1 Hmm\'85 although I can see that, in the absence of curly brackets for statement blocks, like in C, it helps with readability (in terms of the indenting layout) in cases like this:\
\pard\tx529\pardeftab529\pardirnatural\partightenfactor0

\f2\fs22 \cf0 \CocoaLigature0         \cf2 if\cf0  (period != \cf3 -1\cf0 \
            \cf2 and\cf0  len(periods) >= (\cf3 5\cf0  + (\cf3 2\cf0  * settings[\cf4 "numExtraRefFrames"\cf0 ]))\
            \cf2 and\cf0  period > \cf3 6\cf0 \
            \cf2 and\cf0  (len(periods) - \cf3 1\cf0  - settings[\cf4 "numExtraRefFrames"\cf0 ]) > \cf3 0\cf0 \
            \cf2 and\cf0  (periods[len(periods) - \cf3 1\cf0  - settings[\cf4 "numExtraRefFrames"\cf0 ]]) > \cf3 6\cf0 \
        ):\
            periodToUse = periods[len(periods) - \cf3 1\cf0  - settings[\cf4 "numExtraRefFrames"\cf0 ]]\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs24 \cf0 \CocoaLigature1 \

\b \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0
\cf0 \'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97 Architecture sketch \'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0
\cf0 \

\b0 I am still working on this, but I think there are benefits to having things in their own (concurrent) threads, which in python effectively means they are separate 
\i processes
\i0  that must pass messages to each other (or be spawned and return asynchronously). For interfacing with M^2 system, I want a Sync Analyzer process that is driven by [low-level loopback IP?] messages sent back and forth between it and a client. On the RPi, we would also have a Sync Controller process, which would probably be the existing Flask loop, to take care of interfacing with camera/pins hardware. This Sync Controller would be in asynchronous communication with Sync Analyzer, but could also potentially be receiving GUI input from a web client interface.\
\
Messages from Controller to Analyzer would mostly be messages containing frame data, but with other messages to send config information, reset, etc. \
Messages from Analyzer to Controller would mostly be timestamps at which to schedule triggers, but with other messages such as informing when sync lock is acquired.\
\
(In fact, the LTU might well end up being yet another separate process of its own, because it takes such a long time to complete its calculations, but that\'92s a secondary detail\'85)\
\
\
This architecture is helpful in terms of interfacing with the M^2 system (and others) - the Sync Analyzer process would just be in communication with their own software instead of the RPi Sync Controller. However, this architecture has a drawback on the RPi, that it involves separate processes and unnecessarily-onerous message-passing of raw frame data. 
\b I think we can circumvent that
\b0  (and effectively have a more direct functional API layer that would allow RPi python Sync Controller to call through directly to Sync Analyzer. But I want to understand a bit more about how the Flask thing behaves before I describe exactly how that functional API layer would work.
\b \
\
\
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97 from here down these are just notes to myself; work in progress \'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
\
A brain-dump which felt relevant
\b0 , but which currently doesn\'92t make any particular comment on the open-optical-gating architecture\'85\
In my ObjC code, I have two separate entities, the SyncController and the SyncAnalyzer. The former is tightly integrated into the GUI, runs in the \'93main event loop\'94, and is responsible for holding the \'93settings\'94 object. The latter is completely stateless, runs asynchronously in response to frame arrivals, is multithreaded, and could in principle be processing a significant backlog of frames and therefore be \'93lagging behind\'94 the GUI. It is passed frame objects, to which are attached the \'93settings\'94 object 
\i as it was
\i0  
\i at the time the frame was received
\i0 . I can\'92t now remember exactly why I felt that was necessary and/or a good idea, but it must have had something to do with the backlog scenario. Off the top of my head, I now can\'92t think what specific and significant problem that might have been addressing, beyond a general concern that changes to the sync parameters via the GUI would be having a \'93retrospective\'94 effect on frames that had been received before the user changed the setting. Clearly we don\'92t want to get into a situation where we are backlogged, anyway, because the sync will not work well under those circumstances. [To be honest, if we have more than a tiny backlog when generating triggers, we would be better off just abandoning most of the backlogged frames\'85 although then we will need to be careful to allow for variable time gaps in the phase history]\
-> evidently the pi analyze() method must return before the next frame is acquired. It\'92s not clear what happens if it doesn\'92t! Significant risk it won\'92t, if doing LTU. What happens then\'85?\
It would make a lot more sense, and save a lot of passing around of long parameter lists, if there was one object that maintains the pog settings, history, 
\i and
\i0  does the analysis logic. Or at a minimum, the history buffers required by LTU could be maintained by that LTU object (if that seems appropriate). \
\
determine_reference_period passes the \'93settings\'94 object back and forth, 
\i and modifies it
\i0 . I need to think about the best way to handle this. It gets confusing (and DRP does not belong as methods inside a \'93settings\'94 class, so we can\'92t resolve the problem that way). Actually, the modification is trivial and probably can just be a return value instead. In general, I think we may be able to resolve by distinguishing between true \'93settings\'94 parameters, and 
\i state
\i0  (i.e. reference period and frames). If the state is maintained in some sort of sync object, we can pass settings back and forth as needed more easily, I think. The key thing, consistent with my own code, is that there is only one object responsible for curating 
\i and modifying
\i0  that sync state.\
\

\b Architectural considerations
\b0 \
RPi camera object, remote camera via message-passing\
Separate analyzer object\
Settings object [who owns?]\
Pins\
Status reporting via messages\
Stages [currently they interact with stages in pog_state() and analyze() (!)]\
Emulation}